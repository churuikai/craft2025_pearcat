/*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 *  ██████╗  █████╗ ████████╗ █████╗     ██╗  ██╗
 *  ██╔══██╗██╔══██╗╚══██╔══╝██╔══██╗    ██║  ██║
 *  ██║  ██║███████║   ██║   ███████║    ███████║
 *  ██║  ██║██╔══██║   ██║   ██╔══██║    ██╔══██║
 *  ██████╔╝██║  ██║   ██║   ██║  ██║    ██║  ██║
 *  ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝    ╚═╝  ╚═╝
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【模块功能】
 * ┌─────────────────┬───────────────────────────────────────────────────────────┐
 * │ 数据分析        │ 提供数据分析工具和算法接口                                   │
 * ├─────────────────┼───────────────────────────────────────────────────────────┤
 * │ 标签管理        │ 实现标签频率相似度计算和排序                                 │
 * ├─────────────────┼───────────────────────────────────────────────────────────┤
 * │ 系统支持        │ 为其他模块提供数据分析结果                                   │
 * └─────────────────┴───────────────────────────────────────────────────────────┘
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━*/

#pragma once
#include <vector>
#include <map>
#include <unordered_map>
#include "ctrl_disk_obj_req.h"

/*╔══════════════════════════════ 全局变量定义 ═══════════════════════════════╗*/
/**
 * @brief     频率三维数组
 * @details   存储系统运行过程中的频率数据:
 * ┌──────────────────────────────────────────────────────────────────────┐
 * │ 维度1: 时间维度 - 记录不同时间点                                       │
 * │ 维度2: 标签维度 - 存储不同标签                                         │
 * │ 维度3: 操作维度 - 包含读写等操作                                       │
 * └──────────────────────────────────────────────────────────────────────┘
 */
extern std::vector<std::vector<std::vector<int>>> FRE;
/*╚═════════════════════════════════════════════════════════════════════════╝*/

/*╔══════════════════════════════ 接口函数定义 ═══════════════════════════════╗*/
/**
 * @brief     获取特定时间的令牌数
 * @param     timestamp 时间戳
 * @return    int 令牌数
 * @details   根据时间戳计算系统可用的令牌数量
 */
int get_token(int timestamp);

/**
 * @brief     获取排序后的当前时间读频率的tag
 * @param     timestamp 时间戳
 * @return    std::vector<int>& 按读取频率排序的标签列表
 * @details   返回按照读取频率降序排列的标签序列
 */
std::vector<int>& get_sorted_read_tag(int timestamp);

/**
 * @brief     获取与指定标签读取频率相似的标签序列
 * @param     time 时间点
 * @param     tag 标签ID
 * @param     mode 模式选择:
 * ┌──────────────────────────────────────────────────────────────────────┐
 * │ 1: 仅考虑当前时间点的相似度                                            │
 * │ 2: 考虑全部时间范围的相似度                                            │
 * │ 3: 考虑当前时间及未来时间的相似度                                       │
 * └──────────────────────────────────────────────────────────────────────┘
 * @return    std::vector<int> 相似标签列表
 */
std::vector<int> get_similar_tag_sequence(int time, int tag, int mode);

/**
 * @brief     处理数据分析
 * @details   执行系统数据的预处理和分析:
 * ┌──────────────────────────────────────────────────────────────────────┐
 * │ 1. 数据预处理：清洗和标准化数据                                         │
 * │ 2. 频率分析：计算各类操作频率                                           │
 * │ 3. 相似度计算：分析标签间的相似关系                                     │
 * └──────────────────────────────────────────────────────────────────────┘
 */
void process_data_analysis();

/**
 * @brief     计算标签顺序
 * @details   根据多个维度的指标对标签进行排序:
 * ┌──────────────────────────────────────────────────────────────────────┐
 * │ 1. 访问频率：读写操作的频率统计                                        │
 * │ 2. 时间相关性：标签在时间维度上的关联                                   │
 * │ 3. 空间局部性：标签在空间上的分布特征                                   │
 * └──────────────────────────────────────────────────────────────────────┘
 */
void compute_tag_order();
/*╚═════════════════════════════════════════════════════════════════════════╝*/

/*╔══════════════════════════════ 辅助函数定义 ═══════════════════════════════╗*/
/**
 * @brief     归一化曲线数据
 * @param     curve 输入曲线数据
 * @return    std::vector<double> 归一化后的曲线
 * @details   将输入数据转换到统一的尺度范围内
 */
std::vector<double> __normalize_curve(const std::vector<double> &curve);

/**
 * @brief     计算两条曲线的相似度
 * @param     curve1 第一条曲线
 * @param     curve2 第二条曲线
 * @param     normalize_curve1 是否归一化第一条曲线
 * @param     normalize_curve2 是否归一化第二条曲线
 * @return    double 相似度值
 * @details   使用特定的相似度度量方法计算两条曲线的相似程度
 */
double __compute_similarity(const std::vector<double> &curve1, 
                          const std::vector<double> &curve2, 
                          bool normalize_curve1 = true, 
                          bool normalize_curve2 = true);
/*╚═════════════════════════════════════════════════════════════════════════╝*/
