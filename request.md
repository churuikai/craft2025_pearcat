### 1. 题目总体思路

本题要求设计一个分布式对象存储系统中的“控制模块”。该模块负责处理外部发来的写入、读取和删除操作，并对硬盘数据存储进行管理。主要目标是在保证数据可靠性（通过三副本冗余机制）的同时，降低硬盘数据的碎片化程度，提高读取效率。为此，选手需要：

- **写入阶段：** 根据对象的大小、标签等信息，将一个对象拆分为若干个对象块，并将其三个副本分别写入到三个不同的硬盘上（每个副本内的对象块可以不连续，但必须在同一盘上，且写入的存储单元必须为空）。
- **读取阶段：** 规划硬盘上磁头的移动。磁头从初始位置（存储单元1）开始，根据允许的动作（Jump、Pass、Read）在限定的令牌数内移动，读取对象块。一个读取请求只有当对象中每个块至少有一个副本被读取过时，才能认为读取成功。  
- **删除阶段：** 当对象被删除时，所有还未完成的与该对象相关的读取请求需要被立即取消。

此外，题目中还引入了对象标签的概念，即相同标签的对象在时间上具有较高的访问相关性，选手可据此设计策略以降低碎片化和提高读写效率。

---

### 2. 系统背景和主要概念

- **分布式对象存储系统：**  
  - 由多个节点构成，每个节点管理一块硬盘。  
  - 每块硬盘由编号为1到𝑉的存储单元组成，这些存储单元呈环形排列（第𝑉个单元的下一个是1）。

- **对象及其拆分：**  
  - 一个对象包含数据和元数据，并会被拆分成若干“对象块”，每个对象块正好占据一个存储单元。  
  - 对象的大小即为拆分后的对象块数量（1 ≤ 对象大小 ≤ 5）。

- **副本冗余机制：**  
  - 每个对象必须有恰好三个副本。  
  - 同一副本内的所有对象块必须存放在同一块硬盘上；而不同副本必须分布在三块不同的硬盘上。  
  - 若在三个不同的硬盘上找不到足够空间存放对象，则选手程序将判为0分。

- **对象标签：**  
  - 每个对象在写入时附带一个标签，表示对象在某些特征上可能相似（如文件格式、大小、生命周期等）。  
  - 具有相同标签的对象在时间上更可能被集中读取，选手可利用此规律优化存储布局，减少碎片化。

- **存储介质（硬盘）及磁头：**  
  - 每块硬盘由若干存储单元和一个磁头组成。  
  - 磁头负责读取数据，其运动受到“令牌”数限制，每个时间片内每个磁头最多可消耗𝐺个令牌。

- **磁头动作及令牌消耗：**  
  - **Jump：**  
    - 可以在时间片开始时执行一次，直接跳到指定的存储单元。  
    - 消耗固定𝐺个令牌，执行后本时间片内不允许再进行其他动作。  
  - **Pass：**  
    - 磁头从当前位置𝑥移动到下一个存储单元，即 (𝑥 % 𝑉) + 1。  
    - 消耗1个令牌。  
  - **Read：**  
    - 在读取当前存储单元后，磁头同样移动至下一个存储单元。  
    - 第一次或前一次动作不是“Read”的情况消耗64个令牌；  
    - 若上一次Read消耗为𝑝𝑟𝑒_𝑡𝑜𝑘𝑒𝑛，则本次消耗为 𝑚𝑎𝑥(16, ceil(𝑝𝑟𝑒_𝑡𝑜𝑘𝑒𝑛 × 0.8))（ceil表示向上取整）。

---

### 3. 判题过程与得分规则

#### （1）判题交互阶段划分

交互过程分为两个阶段：

1. **全局预处理阶段**  
2. **每个时间片的交互阶段**（共进行 𝑇 + 105 个时间片，其中时间片 𝑇+1 至 𝑇+105 内不会有新的删除、写入或读取请求）

#### （2）得分规则（仅针对读取请求）

对于一个对象（大小为 𝑠𝑖𝑧𝑒）：
- 假设某读取请求在第𝑖个时间片到达，并在第𝑖 + 𝑥个时间片上报读取成功，则其得分计算为  
  𝑆𝐶𝑂𝑅𝐸𝑆 = 𝑓(𝑥) × 𝑔(𝑠𝑖𝑧𝑒)
  
- **函数 f(x) 定义：**  
  - 当 0 ≤ 𝑥 ≤ 10： 𝑓(𝑥) = −0.005×𝑥 + 1  
  - 当 10 < 𝑥 ≤ 105： 𝑓(𝑥) = −0.01×𝑥 + 1.05  
  - 当 𝑥 > 105：  𝑓(𝑥) = 0

- **函数 g(size) 定义：**  
  - 𝑔(𝑠𝑖𝑧𝑒) = (𝑠𝑖𝑧𝑒 + 1) × 0.5

若某读取请求在交互结束后仍未完成，则得分记为0。

---

### 4. 输入与输出要求

#### A. 全局预处理阶段

**输入：**

1. 一行5个整数：  
  T M N V G  
  - T：主时间片数（1 ≤ T ≤ 86400）  
  - M：对象标签数（1 ≤ M ≤ 16）  
  - N：硬盘数（3 ≤ N ≤ 10）  
  - V：每块硬盘的存储单元数（1 ≤ V ≤ 16384）  
  - G：每个磁头在每个时间片最多可消耗的令牌数（64 ≤ G ≤ 1000）

2. 接下来共有 3×M 行，每行包含 ceil(T/1800) 个整数，分为三个部分：  
  - 前 M 行：fre_del 数组，每行第 𝑗 个数表示当时间片在区间 [(𝑗−1)*1800+1, 𝑗×1800] 内，对象标签为当前行编号的所有删除操作中对象大小的总和。  
  - 接下来的 M 行：fre_write 数组，含义类似，表示写入操作中对象大小的总和。  
  - 最后 M 行：fre_read 数组，表示读取操作中对象大小的总和（注意，同一对象被多次读取会重复计数）。

**输出：**

- 输出一行 "OK"（后跟换行符），表示预处理阶段结束，然后刷新输出缓冲区。

---

#### B. 每个时间片的交互阶段

在每个时间片，交互依次包含以下事件：

1. **时间片对齐事件**

   - **输入：**  
     一行：  
   "TIMESTAMP current_timestamp"  
     其中 current_timestamp 为当前时间片编号（范围 1 ~ T+10^5，每次递增1）。

   - **输出：**  
     原样输出 "TIMESTAMP current_timestamp"。

2. **对象删除事件**

   - **输入：**  
     - 第一行：整数 n_delete（本时间片需要删除的对象个数，可能为0）。  
     - 接下来 n_delete 行：每行一个整数 obj_id，表示待删除的对象编号（保证对象存在于系统中）。

   - **输出：**  
     - 第一行：整数 n_abort，表示本时间片取消的读取请求数量（如果没有则输出 "0"）。  
     - 接下来 n_abort 行：每行一个整数 req_id，代表被取消的读取请求编号（输出顺序可任意，但数量必须与 n_abort 一致）。

   - **说明：**  
     删除操作立即生效，与磁头位置无关；取消的请求必须是当前尚未完成、目标对象正被删除的读取请求。

3. **对象写入事件**

   - **输入：**  
     - 第一行：整数 n_write，表示本时间片内写入的对象数。  
     - 接下来 n_write 行：每行包含3个整数  
   obj_id  obj_size  obj_tag  
     其中：  
   - obj_id：对象编号（从1开始，每次递增）。  
   - obj_size：对象大小，即拆分成的对象块数量（1 ≤ obj_size ≤ 5）。  
   - obj_tag：对象标签编号（1 ≤ obj_tag ≤ M）。

   - **输出：**  
     对于每个写入的对象，输出共4行数据（写入的对象顺序可任意，但必须在本时间片处理完所有写入请求）：  
     - 第一行：输出对象编号 obj_id。  
     - 接下来的三行分别表示该对象的三个副本的写入结果，每一行格式为：  
   rep  unit[1]  unit[2]  …  unit[obj_size]  
       其中 rep 表示该副本写入的硬盘编号；unit[k] 表示该副本中第 k 个对象块写入的存储单元编号。

   - **要求：**  
     - 同一副本的所有对象块必须写在同一块硬盘上；  
     - 三个副本必须分别写入三个不同的硬盘；  
     - 写入的存储单元必须为空（未被其他对象块占用）；  
     - 如果无法在三个不同硬盘上为对象分配足够空间，选手程序将判为0分。

4. **对象读取事件**

   - **输入：**  
     - 第一行：整数 n_read，表示本时间片内读取请求的个数。  
     - 接下来 n_read 行：每行包含两个整数  
   req_id  obj_id  
       其中：  
   - req_id：读取请求编号（从1开始，每次递增）。  
   - obj_id：读取目标对象编号（保证对象在请求到来时存在于系统中）。

   - **输出：**  
     分两部分输出：
     
     **（a）磁头运动指令：**  
     - 输出 N 行，每行对应1至N号硬盘的磁头操作。  
       - 如果某块硬盘的磁头在当前时间片执行了 Jump 动作，则该行输出格式为：  
   "j X"  
         其中 X 为跳跃到的存储单元编号；注意：执行 Jump 后，该磁头在本时间片内不得进行其他动作。  
       - 如果未执行 Jump，则输出一个仅包含字符 'p'、'r'、'#' 的字符串，表示磁头在本时间片内依次执行的动作：  
         - 'p' 表示 Pass（消耗1个令牌，将磁头从当前单元移动至 (x % V) + 1）；  
         - 'r' 表示 Read（读取当前单元数据并移动到下一个单元，其令牌消耗规则如下：  
    · 如果是本时间片内第一次执行或上一次动作非 Read，则消耗 64 个令牌；  
    · 否则，若上一次 Read 消耗了 𝑝𝑟𝑒_𝑡𝑜𝑘𝑒𝑛，则本次消耗为 max(16, ceil(𝑝𝑟𝑒_𝑡𝑜𝑘𝑒𝑛 × 0.8)) 个令牌）。  
         - 字符串以 '#' 结束，表示本磁头的动作序列结束。  

     **（b）读取请求上报：**  
     - 输出一行整数 n_rsp，表示本时间片上报成功的读取请求数。  
     - 接着输出 n_rsp 行，每行一个整数 req_id，代表本时间片上报成功的读取请求编号。

   - **说明：**  
     - 一个读取请求需要在其到达时间片后，通过各硬盘磁头读取目标对象的所有对象块（只要每个对象块在至少一个副本中被读取，即可认为读取完成）。  
     - 读取操作允许跨越多个时间片，但对于同一请求，上报成功只能一次；若在交互结束后仍未完成，则得分为0。

---

### 5. 交互其他注意事项

- **刷新输出缓冲：**  
  每个阶段（全局预处理结束、每个时间片事件结束）输出后，必须刷新输出缓冲区（例如 Python 中使用 stdout.flush()）。

- **严格格式要求：**  
  输出必须严格按照题目规定的格式（包括空格、换行等），不得多输出额外字符，否则会导致判题错误或程序卡住。

- **运行效率：**  
  每个时间片中可能包含大量操作，选手需注意代码效率，保证整体交互能够在规定时间内完成。

- **时间片范围：**  
  交互共进行 T + 10^5 个时间片，其中后 10^5 个时间片无新增请求，但仍需按照格式输出对应内容。

---

以上即为对题目思路、核心要求、公式及各个交互阶段输入输出要求的完整表述，涵盖了从全局预处理到各时间片内“时间片对齐”、“对象删除”、“对象写入”和“对象读取”事件的所有细节。力求解决磁盘碎片化问题，减少读取消耗，得到最优分数。