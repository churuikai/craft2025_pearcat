# 2025 软件精英挑战赛复赛赛题要求

## 1. 赛题背景

近年来，随着大模型和生成式 AI 技术的快速发展，AI 应用在各行各业中呈现爆发式增长。作为承载海量数据与高并发读写请求的基石，云存储成为了提升 AI 训练和推理效率的重要环节。然而，在面对 AI 训练过程中大量小文件的高并发读写和大规模 CheckPoint 机制的需求时，传统分布式存储系统可能会遭遇如下挑战：
- **海量数据带来的存储成本问题**  
- **随机访问场景下的磁头频繁移动与性能瓶颈**  
- **如何在高负载下依然保证系统的可用性与可靠性**

为此，本题通过模拟一个**分布式对象存储系统**的核心逻辑，让参赛选手根据赛题给定的规则与交互约束，设计并实现系统中的**控制模块**，从而平衡高并发场景下的读写性能、存储布局及系统可靠性。

---

## 2. 赛题描述

### 2.1 赛题概述

在本题中，选手需要实现一个分布式对象存储系统的“控制模块”。该模块需要：
1. **处理外部发来的写入、读取和删除请求**，并为每个对象提供恰好三份数据副本。
2. **将对象按块（对象块）进行拆分**，同时根据标签特征进行合理的空间布局，降低硬盘碎片化程度，提高读取效率。
3. **对磁头移动进行规划**（尤其是读取阶段），在给定的令牌消耗限制内完成对象数据的读取并及时上报结果。
4. **复赛新增**：在**特定时间片（1800 的倍数）**可进行**垃圾回收（GC）**，对同一块硬盘内的存储单元进行数据互换，以进一步减少碎片化或调整布局；并在**过载保护**场景下，对无法在规定时间内完成的请求提前上报繁忙，从而避免系统崩溃。

---

### 2.2 分布式对象存储系统介绍

- **多块硬盘组成**  
  系统共有 \(N\) 块硬盘，每块硬盘具备从 1 到 \(V\) 的 **存储单元**，且这些单元呈环形排列（在单元编号 \(V\) 之后返回 1）。
- **单块硬盘结构**  
  - 每个存储单元可存放 1 个对象块。  
  - 每块硬盘有 **2 个磁头**，只能单向（向编号更大的存储单元方向）移动；编号为 \(V\) 的存储单元的下一个是 1 。
- **控制模块**  
  - 系统对外的所有读写删请求均由**控制模块**进行调度和执行。  
  - 写入和删除请求的执行不依赖磁头位置，立即生效；读取请求需要磁头移动并消耗令牌。

---

### 2.3 对象冗余机制介绍

- 每个对象需在 **3 块不同的硬盘**上写入 3 份副本。  
  - 同一个副本内的对象块必须在同一块硬盘上；  
  - 不同副本不能分配到同一块硬盘；  
  - 若无法找到 3 块剩余空间足够的硬盘，选手程序将被判为 0 分。
- 对象被拆分成若干**对象块**（大小 = 对象块数），本题中对象大小 \(1 \le \text{size} \le 5\)。  
- 对象编号（obj_id）从 1 开始，每次递增 1。

---

### 2.4 对象标签介绍

- 每个对象附带一个 **标签编号（1 ~ M）**。  
- 相同标签的对象往往在时间上有相似的访问特征（如相近的读取需求、相似的生命周期等），可以利用此规律减少碎片化、提升系统整体性能。  
- 比赛开始前的**全局预处理阶段**会提供：  
  1. `fre_del`：不同时间段对各标签对象的删除请求中所有对象块数量总和  
  2. `fre_write`：不同时间段对各标签对象的写入请求中所有对象块数量总和  
  3. `fre_read`：不同时间段对各标签对象的读取请求中所有对象块数量总和（对象被多次读会多次计数）  
  选手可根据这类统计信息，为后续时间片制定合理策略（例如对“即将频繁读取”的标签集中放置以减少磁头的移动路径等）。

---

### 2.5 存储介质介绍（硬盘与磁头）

- **存储单元编号**：1 到 \(V\)，环形排列。  
- **磁头**：  
  - 每块硬盘有 2 个磁头，每个磁头在每个时间片内最多消耗 \(G\) 个令牌。  
  - 磁头动作包括：
    1. **Jump**：瞬时跳转到任意存储单元（消耗 \(G\) 个令牌，且本时间片该磁头不得再执行其他动作）。  
    2. **Pass**：从单元 \(x\) 移动到下一个单元 \((x \% V) + 1\)，消耗 1 个令牌。  
    3. **Read**：读取当前单元并移动到下一个单元，第一次或上一次动作非 Read 时消耗 64 个令牌；若连续执行 Read，则后续读的令牌消耗为 \(\max(16, \lceil pre\_token \times 0.8\rceil)\)。

---

### 2.6 存储系统垃圾回收机制介绍

> **复赛新增**：**垃圾回收（GC）** 允许选手在特定时间片进行数据搬迁，以减少碎片化。

- **触发时机**：当时间片编号为 1800 的倍数时，系统会进入垃圾回收阶段。  
- **操作限制**：每块硬盘最多进行 \(K\) 次存储单元之间的**数据交换**。  
- **数据交换**：选手可以在同一块硬盘内，任选**两个**存储单元 \(A\) 与 \(B\)，使两者所存储的数据进行互换。该过程**瞬时完成**，无需磁头移动或令牌消耗。  
- **意义**：可将同一标签或在未来更可能被集中读取的对象进行就近归并，以优化后续磁头的移动路径并提高顺序读写效率。

---

### 2.7 存储系统过载保护机制介绍

> **复赛新增**：当请求量过高时，系统可上报“请求繁忙”以防止积压的请求拖垮整体性能。

- **读取请求的有效时限**：每个读取请求从到达开始，有 **\(105\)** 个时间片可供调度。如果在这段时限内未能完成且未上报其他结果，系统会强制结束判题，选手得分记 0。  
- **请求繁忙上报**：如果系统预估无法在 \(105\) 时间片内读完对象全部块，可以随时向判题器上报“请求繁忙”，判题器将根据上报时机对选手进行扣分（扣分公式见后述）。  
- **删除请求的影响**：当对象被删除，若有尚未完成的读取请求，需立即上报取消（此类读请求得分为 0）。

---

## 3. 判题过程

整个判题过程包含 **\(T + 105\)** 个时间片，时间片编号范围为 \(1 \le \text{current\_timestamp} \le T + 105\)。其中：
- **前 \(T\) 个时间片**：系统会依次输入可能的写入、读取及删除请求。  
- **后 \(105\) 个时间片**：不再有新请求，但需要继续处理之前尚未完成的读请求，或进入垃圾回收阶段。  

在每个时间片，判题器会依次触发以下事件并等待选手响应：

1. **时间片对齐事件**  
   - 输入：`TIMESTAMP current_timestamp`  
   - 选手需原样输出：`TIMESTAMP current_timestamp`  
   - 用于双方保持一致的时间片编号。

2. **对象删除事件**  
   - 输入：`n_delete`；随后 `n_delete` 行，每行一个 `obj_id`。  
   - 输出：`n_abort`；随后列出 `n_abort` 个 `req_id`（表示被取消的读取请求编号）。  
   - 删除操作立即生效，不受磁头位置影响。

3. **对象写入事件**  
   - 输入：`n_write`；随后 `n_write` 行，每行 `obj_id obj_size obj_tag`。  
   - 输出：对每个写入对象，依次输出 4 行：  
     1. 对象编号 `obj_id`  
     2. 第一个副本的 `(硬盘编号 + size 个存储单元编号)`  
     3. 第二个副本的 `(硬盘编号 + size 个存储单元编号)`  
     4. 第三个副本的 `(硬盘编号 + size 个存储单元编号)`  
   - 对象写入同样立即生效，不需磁头移动。

4. **对象读取事件**  
   - 输入：`n_read`；随后 `n_read` 行，每行 `req_id obj_id`。  
   - 输出内容包括：  
     1. **磁头动作**（N 行×2，分别对应 N 块硬盘的两个磁头）：  
        - 若该磁头执行 Jump，则输出 `j X`；其中 `X` 为跳转到的存储单元编号，并且 Jump 后本时间片该磁头不能再执行其他动作。  
        - 若未执行 Jump，则输出由 `p`（Pass）或 `r`（Read）组成的字符串，最后以 `#` 结束。例如 `ppr#` 表示先 Pass 两次、再 Read 一次并结束本磁头动作。  
     2. **本时间片成功读取的请求**：输出 `n_rsp` 和其后 `n_rsp` 行成功完成的 `req_id`。  
     3. **本时间片上报繁忙的请求**：输出 `n_busy` 和其后 `n_busy` 行的 `req_id`。被上报繁忙的请求将根据时机扣分。  
   - 对象读取需要跨越多个时间片进行磁头移动，一旦对象中每个块至少被读取过一次（可跨副本），即可在后续某时间片上报读取成功。

5. **垃圾回收事件**（当时间片编号为 1800 的倍数时出现）  
   - 选手可对每块硬盘进行最多 \(K\) 次存储单元的**交换操作**（同一块硬盘内任意两个单元 \(A\) 和 \(B\) 的数据相互交换，瞬时完成）。  
   - 输出格式：  
     1. 对每块硬盘先输出一个整数，表示该硬盘本次垃圾回收要进行的交换次数。  
     2. 随后输出对应数量的 `(A B)` 对，表示要交换的两个存储单元编号。

---

## 4. 得分规则

系统只对读取请求进行计分或扣分：

1. **读取成功的得分**  
   - 若请求在第 \(i\) 个时间片发起，并在第 \(i + x\) 个时间片上报读取成功，则得分：
     \[
       \mathrm{SCORES} = f(x) \times g(\mathrm{size}),
     \]  
     其中：
     \[
       f(x) = 
       \begin{cases}
       -0.005\,x + 1, & 0 \le x \le 10, \\
       -0.01\,x + 1.05, & 10 < x \le 105, \\
       0, & x > 105
       \end{cases}
       \quad,\quad
       g(\mathrm{size}) = \frac{\mathrm{size} + 1}{2}.
     \]

2. **请求繁忙的扣分**  
   - 若在第 \(i + x\) 个时间片上报“请求繁忙”，则扣分：
     \[
       \mathrm{SCORES} = h(x) \times g(\mathrm{size}), \quad
       h(x) = \frac{x}{105}.
     \]
   - 其中 \(x\) 表示该读请求从到达到上报繁忙之间的时间片间隔。

3. **请求超时**  
   - 若一个读请求在到达后经过 \(105\) 个时间片仍未上报成功或繁忙，则判题器会立即终止判分，并给选手记 **0 分**。

4. **删除请求造成的读取取消**  
   - 若对象被删除，则与该对象相关的未完成读请求需立即取消，该请求得分记 **0**。

选手的**总得分**为所有读取请求得分之和减去繁忙请求的扣分值。若出现任何写入时无法满足三副本放置的情况、或读取请求未在 \(105\) 时间片内上报结果导致系统终止，最终得分即为 **0**。

---

## 5. 输入与输出

### 5.1 全局预处理阶段

1. 判题器首先输出 **5+1 个整数**：  
   ```
   T M N V G K
   ```  
   - **T**：主时间片数（1 ≤ T ≤ 86400），后续交互总时间片数为 \(T + 105\)。  
   - **M**：对象标签数（1 ≤ M ≤ 16）。  
   - **N**：硬盘数（3 ≤ N ≤ 10）。  
   - **V**：每块硬盘的存储单元数（1 ≤ V ≤ 16384）；保证任意时刻整体空闲单元数≥总单元数的 10%。  
   - **G**：每个磁头在每个时间片最多消耗的令牌数（64 ≤ G ≤ 500）。  
   - **K**：每逢 1800 时间片垃圾回收时，每块硬盘允许进行的交换操作次数上限（0 ≤ K ≤ 100）。

2. 接下来判题器输出 **3×M 行**，每行含有 \(\lceil T/1800\rceil\) 个整数：
   - 前 M 行：`fre_del[i][j]`，表示在第 \((j-1)*1800 + 1\) 到 \(j*1800\) 时间片之间，对象标签为 \(i\) 的对象的**删除**操作中，对象块数量总和。
   - 中间 M 行：`fre_write[i][j]`，与上同理，但统计**写入**操作。
   - 后 M 行：`fre_read[i][j]`，与上同理，但统计**读取**操作（多次读取会重复计数）。

3. 选手在完成预处理后，输出：  
   ```
   OK
   ```
   表示已完成初始化和策略准备，并刷新输出缓冲。

### 5.2 每个时间片的交互

重复进行 **\(T + 105\)** 次，顺序包括：

1. **时间片对齐事件**  
   - 输入：`TIMESTAMP current_timestamp`  
   - 输出：`TIMESTAMP current_timestamp`

2. **对象删除事件**  
   - 输入：第一行为 `n_delete`；随后 `n_delete` 行为各待删除的 `obj_id`。  
   - 输出：第一行为 `n_abort`；随后 `n_abort` 行，列出被取消读取的请求编号 `req_id`。

3. **对象写入事件**  
   - 输入：第一行为 `n_write`；随后 `n_write` 行：`obj_id obj_size obj_tag`。  
   - 输出：对于每个写入对象，依次输出 4 行：
     1. 对象编号  
     2. 第一个副本：`rep unit[1] unit[2] ... unit[obj_size]`  
     3. 第二个副本：同上  
     4. 第三个副本：同上  

4. **对象读取事件**  
   - 输入：第一行为 `n_read`；随后 `n_read` 行：`req_id obj_id`。  
   - 输出：
     1. **磁头动作指令**：共 **2×N 行**，每块硬盘的两个磁头各一行。  
        - 若执行 Jump：`j X`  
        - 否则输出由 `p`、`r`、`#` 组成的字符串，`#` 结尾。  
     2. 一行 `n_rsp`；随后 `n_rsp` 行，列出本时间片上报读取成功的请求编号。  
     3. 一行 `n_busy`；随后 `n_busy` 行，列出本时间片上报繁忙的请求编号。

5. **垃圾回收事件**（当前时间片编号是 1800 的倍数时出现）  
   - 每块硬盘最多执行 \(K\) 次数据交换，每次交换指定同一块硬盘上的两个存储单元：  
     1. 先输出一个整数表示该硬盘本次要交换的次数。  
     2. 随后输出对应行数，每行两个数 `A B` 表示进行交换的存储单元编号。

### 5.3 交互注意事项

1. **输出后刷新**：在 C++ 中通常使用 `std::flush`，Python 中可使用 `sys.stdout.flush()`。若未及时刷新，判题器可能会因读不到输出而卡住。  
2. **严格的输出格式**：多余的空格、换行、字符等都可能导致判题器报错或超时。  
3. **时间效率**：由于写入、读取与删除的请求数可能高达数十万乃至更多，选手需保证程序在有限的运行时间内完成所有交互并输出结果。  
4. **写入-删除-读取 之间的依赖**：对象删除事件会立即清除被删除对象的数据，不同请求的先后次序必须正确处理；读取若尚未完成而对象被删，则该读取请求必须被取消。  
5. **超时处理**：任何读取请求在到达后超过 \(105\) 个时间片未得到结果（成功或繁忙）都会导致选手直接 0 分。要合理安排磁头调度或繁忙上报。